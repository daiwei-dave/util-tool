


未做单独的代码测试，只是结合项目代码做了部分测试及概念理解


demo
1)使用aop进行日志管理




日志的优势：
1.通过查看后台日志，减少不必要的断点调试，减轻调试难度

2.可以知道后台运行情况，确定调试位置

日志的劣势：
1.可能占资源，级别设置太低服务启动打印的语句较多，启动速度将减慢


3.问题
1）log4j.appender.ERROR.File=${catalina.base}/logs/gome-com.gome.platform-web-err.log  日志跑到哪去了？


日志框架：slf4j,Commons-logging，logback，log4j（slf4j和Commons-logging为日志接口，logback和log4j为具体的日志实现）


Commons-logging : apache最早提供的日志的门面接口。避免和具体的日志方案直接耦合。
类似于JDBC 的api 接口，具体的的JDBC driver 实现由各数据库提供商实现。通过统一接口解耦，
不过其内部也实现了一些简单日志方案。


Log4j : 经典的一种日志解决方案。内部把日志系统抽象封装成Logger 、appender（输出源） 、pattern 等实现。
我们可以通过配置文件轻松的实现日志系统的管理和多样化配置。（在.proprety文件里用得最多）


Slf4j : 全称为Simple Logging Facade for JAVA：java简单日志门面。 是对不同日志框架提供的一个门面封装。
可以在部署的时候不修改任何配置即可接入一种日志实现方案。和commons-loging 应该有一样的初衷。个人感觉设从计上更好一些，没有commons 那么多潜规则。同时有两个额外特点：
1. 能支持多个参数，并通过{} 占位符进行替换，避免老写logger.isXXXEnabled 这种无奈的判断，带来性能提升见：http://www.slf4j.org/faq.html#logging_performance 。
2.OSGI 机制更好兼容支持

Logback : LOGBack 作为一个通用可靠、快速灵活的日志框架，将作为Log4j 的替代和SLF4J 组成新的日志系统的完整实现。
官网上称具有极佳的性能，在关键路径上执行速度是log4j 的10 倍，且内存消耗更少。具体优势见：
http://logback.qos.ch/reasonsToSwitch.html




在本地使用时一般调用两个日志接口：
1）
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

2）
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;













引用博客：http://singleant.iteye.com/blog/934593
一。
提出问题：
1.日志的级别有哪些？
2.什么情况下该用哪种级别，及应该怎么用？


解决问题：
通过查看后台日志，分析日志的级别

1.LOG.info:  显示程序运行的阶段与状态
重要的业务逻辑处理完成. 在理想情况下, INFO的日志信息要能让高级用户和系统管理员理解, 
并从日志信息中能知道系统当前的运行状态. 比如对于一个机票预订系统来说, 
当一个用户完成一个机票预订操作之后, 提醒应该给出"谁预订了从A到B的机票".
另一个需要输出INFO信息的地方就是一个系统操作引起系统的状态发生了重大变化(比如数据库更新,
 过多的系统请求). 
 
如：
log.info("活动不存在,活动id: {}",id);   id值将存在于 {}内，且能大大减少性能损耗


1）登录登出


2.LOG.error：
系统发生了严重的错误, 必须马上进行处理, 否则系统将无法继续运行. 比如, NPE, 数据库不可用等
如：
1）.获取的对象或信息为空
log.error("internal_purchase_detail, InternalPurchase#" + id + " is null"); //注意变量的写入方式
2）.添加或创建失败
log.error("无法创建临时目录:"+tmpDir.getPath());

logger.error("删除文件失败,filePath:{}",filePath,e);     {}里将包含变量


3.log.warn：系统能继续运行, 但是必须引起关注. 对于存在的问题一般可以分为两类: 一种系统存在明显的问题(比如, 数据不可用),
 另一种就是系统存在潜在的问题, 需要引起注意或者给出一些建议(比如, 系统运行在安全模式或者访问当前系统的账号存在安全隐患).
 总之就是系统仍然可用, 但是最好进行检查和调整.
 
 
4.log.debug 主要打印一些重要的变量

如：
1）.  log.debug("获取当前的user.dir路径为："+relativelyPath);
 （日志为debug，可减少不必要的打断点调试）

2）.紧接在catch后面

try {
			dateStr = sdf.format(date);
		} catch (Exception e) {
			log.debug("时间字符串转换错误：待转换的时间-->" + date);
		}
		
logger.debug("调用ehrEmployee.addEmployee异常，{}",e);	 {}里将包含异常信息	
		
5.	TRACE
与DEBUG 相比更细致化的记录事件消息。

6.FATAL

指定非常严重的错误事件，这可能导致应用程序中止	
		
		
二。日志的配置问题





配置日志信息输出目的地
log4j.appender.appenderName = fully.qualified.name.of.appender.class
1.org.apache.log4j.ConsoleAppender（控制台）
2.org.apache.log4j.FileAppender（文件）
3.org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）
4.org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）
5.org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）

如：log4j.appender.Console=org.apache.log4j.ConsoleAppender

配置日志信息的格式
log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class
1.org.apache.log4j.HTMLLayout（以HTML表格形式布局），
2.org.apache.log4j.PatternLayout（可以灵活地指定布局模式），
3.org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），
4.org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）

如：log4j.appender.Console.layout=org.apache.log4j.PatternLayout




2.日志信息格式中几个符号所代表的含义：

log4j.appender.Console.layout.ConversionPattern=gome-gsm-web: %d{yyyy-MM-dd HH:mm:ss} %-5p [%C] (%F:%L) - %m%n

如：
gome-gsm-web: 2017-01-12 15:32:45 DEBUG [com.alibaba.druid.filter.logging.Slf4jLogFilter] (Slf4jLogFilter.java:134) - {conn-10008, pstmt-20089} executed. 

1. %d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，
比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921

2.%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL。如果是调用debug()输出的，则为DEBUG，依此类推。
    %-5p：5表示宽度为5（即输出结果以5个字符宽度对齐），负号表示左对齐。
	
可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如：
 1)%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。
 2)%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，"-"号指定左对齐。
 3)%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。
 4)%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边较远输出的字符截掉。	


3. %c: 输出日志信息所属的类目，通常就是所在类的全名

4.%F: 输出日志消息产生时所在的文件名称

5. %L: 输出代码中的行号

6.%m: 输出代码中指定的消息,产生的日志具体信息

7.%n: 输出一个回车换行符，Windows平台为"/r/n"，Unix平台为"/n"输出日志信息换行

8.%logger{36} 表示logger名字最长36个字符，否则按照句点分割。

logger{length}输出日志的logger名，可有一个整形参数，功能是缩短logger名，设置为0表示只输入logger最右边。

参考自：http://blog.csdn.net/arkblue/article/details/7772971


3 配置实例

1）.proprety形式


1.console输出
### 日志信息输出目的地 org.apache.log4j.ConsoleAppender（控制台）
log4j.appender.Console=org.apache.log4j.ConsoleAppender
#配置日志信息的格式 org.apache.log4j.PatternLayout（可以灵活地指定布局模式）
log4j.appender.Console.layout=org.apache.log4j.PatternLayout
#如：gome-gsm-web: 2017-01-12 15:32:45 DEBUG [com.alibaba.druid.filter.logging.Slf4jLogFilter] (Slf4jLogFilter.java:134) - {conn-10008, pstmt-20089} executed.
log4j.appender.Console.layout.ConversionPattern=gome-gsm-web: %d{yyyy-MM-dd HH:mm:ss} %-5p [%C] (%F:%L) - %m%n





2..File 输出
RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），
log4j.appender.R=com.gome.support.log4j.appender.SizeRollingFileAppender
#指定是否是追加写入（append=true，默认情况），还是覆盖写入（append=false）。
log4j.appender.R.Append=true
log4j.appender.R.layout=org.apache.log4j.PatternLayout
log4j.appender.R.encoding=UTF-8
log4j.appender.R.MaxFileSize=50MB
### 设置日志信息文件总数最多为100个 ###
log4j.appender.R.MaxBackupIndex=100
### 设置日志信息文件名为gome-gsm-web.log ###
log4j.appender.R.File=/gome-gsm-logs/gome-gsm-web.log
log4j.appender.R.layout.ConversionPattern=gome-gsm-web: %d{yyyy-MM-dd HH:mm:ss} %-5p [%C] (%F:%L) - %m%n





3.
# 输出错误日志文件
log4j.appender.ErrorFile=com.gome.support.log4j.appender.SizeRollingFileAppender
log4j.appender.ErrorFile.Append=true
log4j.appender.ErrorFile.layout=org.apache.log4j.PatternLayout
log4j.appender.ErrorFile.encoding=UTF-8
log4j.appender.ErrorFile.MaxFileSize=50MB
log4j.appender.ErrorFile.MaxBackupIndex=100
#org.apache.log4j.varia.LevelRangeFilter这是一个基于级别匹配的非常简单的过滤器，可用于拒绝优先级超出一定范围的邮件。
log4j.appender.ErrorFile.filter.ErrorFileFilter=org.apache.log4j.varia.LevelRangeFilter
# 最低级别为error
log4j.appender.ErrorFile.filter.ErrorFileFilter.LevelMin=ERROR
log4j.appender.ErrorFile.File=/gome-gsm-logs/gome-gsm-web-error.log
log4j.appender.ErrorFile.layout.ConversionPattern=gome-gsm-web-error: %d{yyyy-MM-dd HH:mm:ss} %-5p [%C] (%F:%L) - %m%n





4.数据库相关

log4j.logger.com.ibatis=ERROR
#连接池打印error级别
log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=ERROR
#ScriptRunner类用于执行SQL语句,例如创建数据库schema，或传入缺省或测试数据库等等，执行ScriptRunner类打印error级别
log4j.logger.com.ibatis.common.jdbc.ScriptRunner=ERROR
#sqlmap进行映射时打印error级别
log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=ERROR
log4j.logger.java.sql.Connection=ERROR
log4j.logger.java.sql.Statement=ERROR
log4j.logger.java.sql.PreparedStatement=ERROR
log4j.logger.com.alibaba=INFO


2）.xml形式





三。分布式下的日志使用

1。问题
分布式下如何使用日志


2.解决问题：




provider方： 开发者开发时后台打印的日志都在dubbo服务器里

尽可能将级别设置低，便于调试，数据库相关设为DEBUG级别
log4j.rootLogger=DEBUG,CONSOLE

log4j.logger.org.mybatis=DEBUG
log4j.logger.org.springframework=DEBUG
log4j.logger.com.alibaba=DEBUG
log4j.logger.org.apache.zookeeper=DEBUG
log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUG
log4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUG
log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG
log4j.logger.java.sql.Connection=INFO
log4j.logger.java.sql.Statement=ALL
log4j.logger.java.sql.PreparedStatement=ALL

consumer方：开发者开发时后台打印的日志都在tomcat服务器里

可以将日志级别提高，数据库相关设为error级别
log4j.rootLogger=INFO, R,CONSOLE

log4j.logger.com.ibatis=ERROR
log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=ERROR
log4j.logger.com.ibatis.common.jdbc.ScriptRunner=ERROR
log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=ERROR
log4j.logger.java.sql.Connection=ERROR
log4j.logger.java.sql.Statement=ERROR
log4j.logger.java.sql.PreparedStatement=ERROR






1.相当于你调用spring框架的接口，它要打印spring容器里的日志，同时也要打印你自己写的日志。而dubbo框架就将底层的日志全部封装到了底层服务器里。








不同环境下的日志使用

consumer方：

test:
log4j.rootLogger=DEBUG, R,CONSOLE

数据库相关都使用dubug等级

product:   

log4j.rootLogger=INFO, CONSOLE, R,ERROR。     CONSOLE, R,ERROR都将输出到某个文件里

数据库相关都使用WARN等级





四。日志不同环境使用

1.console or file
在开发环境，我们只是输出到控制台没有问题，但是到了生产或测试环境，或许持久化日志内容，方便追溯问题原因。可以通过添加如下的appender内容，按天输出到不同的文件中去，
同时还需要为log4j.rootCategory添加名为file的appender，这样root日志就可以输出到logs/all.log文件中了。（在测试时，看不到控制台，只有在文件中查看日志）

2.级别控制
我们在开发环境大部分模块需要采用DEBUG级别，在测试环境可能需要小部分采用DEBUG级别，而在生产环境时我们又希望采用INFO级别

200，300，500日志等级一般设为dubug,  800环境一般设置info

200，300，500数据库相关一般设为dubug,   800环境数据库相关一般设为WARN



200：






800：多了error，并设置了专门打印error级别的日志（ 设置了：log4j.appender.ERROR.Threshold = ERROR 或者：log4j.appender.ErrorFile.filter.ErrorFileFilter=org.apache.log4j.varia.LevelRangeFilter       log4j.appender.ErrorFile.filter.ErrorFileFilter.LevelMin=ERROR）









五。slf4j













