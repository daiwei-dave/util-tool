一。
1.核心知识
1.1 IO流
1.2 多线程
1.3 jdbc
1.4 三大特性，封装，继承，多态,异常
1.5 网络编程
2.
2.1 jvm（java虚拟机）:底层模块负责加载类，分配内存，垃圾回收等功能
2.2 JRE（Java Runtime Environment，Java运行环境），运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库
三.
1.Writer对象为import java.io.Writer;
Writer writer=response.getWriter();
2.out对象为jsp内置对象， 类型为javax.servlet.jsp.JspWriter 
四.
1.static关键字
就是一个单例


1）Java静态对象和非静态对象有什么区别？
      比对如下：
                                         静态对象                                                        非静态对象     
拥有属性：                是类共同拥有的                                             是类各对象独立拥有的
内存分配：               内存空间上是固定的，是该类独有的                                    空间在各个附属类里面分配,每new一个对象就会单独分配一个内存空间
分配顺序：               先分配静态对象的空间，加载类时                    继而再对非静态对象分配空间,也就是初始化顺序是先静态再非静态.
       java静态对象到底有什么好处？
A，静态对象的数据在全局是唯一的，一改都改。如果你想要处理的东西是整个程序中唯一的，弄成静态是个好方法。 非静态的东西你修改以后只是修改了他自己的数据，但是不会影响其他同类对象的数据。 
B，引用方便。直接用 类名.静态方法名  或者  类名.静态变量名就可引用并且直接可以修改其属性值，不用get和set方法。
C，保持数据的唯一性。此数据全局都是唯一的，修改他的任何一处地方，在程序所有使用到的地方都将会体现到这些数据的修改。有效减少多余的浪费。
D，static final用来修饰成员变量和成员方法，可简单理解为“全局常量”。对于变量，表示一旦给值就不可修改；对于方法，表示不可覆盖。
1.静态变量
1.1 一旦被修改，其他地方调用的值都是被修改后的值 
1.2 静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，
静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。（因此静态方法只能访问静态变量）
静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。
2.静态方法
2.1 对方法来说，static 一项重要的用途就是帮助我们在不必创建对象的前提下调用那个方法，类加载完后，静态方法也加载好了
2.2 静态的方法是无法被重写,编译不会报错，但只会执行父类的方法，重些无效。
2.3 静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，
因此在调用静态方法时可能对象并没有被初始化。而实例方法可直接调用本类的类方法
2.4.类方法是指类中被static修饰的方法，无this 或 super指针(可以将this理解为对象，而类方法属于类，不属于对象，所以类方法前不能加this指针)
3.静态块

先静态属性，后静态代码块，同一类型（非数据类型，指以上），按代码先后顺序

静态代码块：  在jvm加载时就进行初始化，且只能引用静态变量
http://www.cnblogs.com/sophine/p/3531282.html



2.final关键字

final关键字的好处

下面总结了一些使用final关键字的好处

final关键字提高了性能。JVM和Java应用都会缓存final变量。（读取更快）
final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
使用final关键字，JVM会对方法、变量及类进行优化。


http://www.importnew.com/7553.html


3.native 关键字  调用的是非java语言

http://blog.csdn.net/funneies/article/details/8949660

五。
声明类
Singleton2 instance；
创建实例
instance=new Singleton2();


初始化过程： 
1. 初始化父类中的静态成员变量和静态代码块 ； 
2. 初始化子类中的静态成员变量和静态代码块 ； 
3.初始化父类的普通成员变量和代码块，再执行父类的构造方法；
4.初始化子类的普通成员变量和代码块，再执行子类的构造方法； 



六。NullPointerException异常

1.当调用空对象的方法或属性等会报  NullPointerException异常



八。
假定文件名是 MyClass.java。它意味着在那个文件有一个、而且只能有一个 public 类。而且那个类
的名字必须是 MyClass（包括大小写形式）：
九。

封装： 封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。
对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法
封装(encapsulation)是计算机常见的术语，即保留有限的外部接口(interface)，隐藏具体实施细节

继承：继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。
接口：为一些功能制定统一的标准
十。
java.lang.reflect：提供类和接口，以获取关于类和对象的反射信息
java.sql 提供使用 JavaTM 编程语言访问并处理存储在数据源（通常是一个关系数据库）中的数据的 API。 
十一。
一个.java文件可以有多个类，但只能有一个public修饰的类（泛指外部类）


十二。泛型 （相当于把存储的类型扩大，使其通用）
泛型（Generic type 或者 generics）是对 Java 语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。
可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样。

如：public class SeckillResult<T> implements Serializable{}
在集合中的应用：
1.List<?>和List 是相等的，都代表最大范围
2.如果尖括号里面带有问号，那么代表一个范围: <? extends A> 代表小于等于A的范围(相当于是属于A的子集)，<? super A>代表大于等于A的范围，<?>代表全部范围
3.尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值
十三。
重载：

方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。
原则如下：
一.方法名一定要相同。
二.方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。
1.如果参数个数不同，就不管它的参数类型了！
2.如果参数个数相同，那么参数的类型或者参数的顺序必须不同。
三.方法的返回类型、修饰符可以相同，也可不同。



重写@Override：






存储：
类中的成员变量，存放在堆区
方法中的局部变量，存放在栈区
方法区：又叫静态存储区，存放class文件和静态数据，线程共享;




13.类的加载
类的加载是由类加载器完成的，类加载器包括：根加载器（ BootStrap ）、扩展加载器（ Extension ）、系统加载器（ System ）和用户自定义类加载器（ java.lang.ClassLoader 的子类）。从 Java 2 （ JDK 1.2 ）开始，类加载过程采取了父亲委托机制（ PDM ）。 PDM 更好的保证了 Java 平台的安全性，在该机制中， JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。 JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明：
Bootstrap ：一般用本地代码实现，负责加载 JVM 基础核心类库（ rt.jar ）；
Extension ：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap ；
system class loader ：又叫应用类加载器，其父类是 Extension 。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。
用户自定义类加载器： java.lang.ClassLoader 的子类 

父类委托机制是可以修改的，有些服务器就是自定义类加载器优先的。

14.垃圾回收
A: 垃圾回收在jvm中优先级相当相当低。
B：垃圾收集器（GC）程序开发者只能推荐JVM进行回收，但何时回收，回收哪些，程序员不能控制。
C：垃圾回收机制只是回收不再使用的JVM内存，如果程序有严重BUG，照样内存溢出。
D：进入DEAD的线程，它还可以恢复，GC不会回收


二。java语法基础


1.常见数学函数：
1.舍掉小数取整:Math.floor(2.5)=2
2、四舍五入的函数
正数：Math.round(11.5)=12
负数：Math.round(-11.5)=-11
3.凑整
Math.ceil(2)=2
Math.ceil(2.1)=3
Math.ceil(2.5)=3
Math.ceil(2.9)=3

4.random类


nextInt(int n)
返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值



5.null泛指对象为空，“”指对象的内容为空字符串



6.hashCode
初学者可以这样理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。
 这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，
 它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。
 所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。
    所以，Java对于eqauls方法和hashCode方法是这样规定的：
1、如果两个对象相同，那么它们的hashCode值一定要相同；
2、如果两个对象的hashCode相同，它们并不一定相同



7.

System.err.println ： err是运行期异常和错误反馈的输出流的方向，再eclipse的console会显示成红色的


8.
int...x就是数组（且此参数可传可不传）
用在方法参数里面
比如public void f(int...x)表示我这个方法接受一个int数组
这个叫变参。。





10.instanceof   判断是哪种类型

instanceof用来判断内存中实际对象A是不是B类型
出现这种情况经常是需要强制转换的时候
https://zhidao.baidu.com/question/455884174.html






11.System
System.err  控制台打印的颜色为红色



12java的基本数据类型

https://zhidao.baidu.com/question/330396820.html






