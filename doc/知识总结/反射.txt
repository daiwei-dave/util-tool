
反射：主要为了理解框架的基本原理



Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；
在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。

一。Class类的使用

1.class Foo{
	
	void print(){
		System.out.println("foo");
	}
//创建此 Class 对象所表示的实例,为单例	
Class c1 = Foo.class;
Foo foo1 = new Foo();
//第二中表达方式  已经知道该类的对象通过getClass方法
Class c2 = foo1.getClass();
Class c3 = null;
		try {
			//创建此 Class 对象所表示的实例,为单例
			c3 = Class.forName("com.imooc.reflect.Foo");
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println(c2==c3);//输出为true
		try {
			//创建该类的对象实例，非静态，与new一个对象等效
			Foo foo = (Foo)c1.newInstance();//需要有无参数的构造方法
			foo.print();
			Foo foo2=(Foo) c3.newInstance();
			System.out.println(foo==foo2);//输出为false
			
输出为：			
true
foo
false




			
2.
T - 由此 Class 对象建模的类的类型。例如，String.class 的类型是 Class<String>。
如果将被建模的类未知，则使用 Class<?>。
如：
/**
	 * 构造函数
	 * @param title 表格标题，传“空值”，表示无标题
	 * @param cls 实体对象，
	 */
	public ExportExcel(String title, Class<?> cls){
		this(title, cls, 1);
	}
	
实现就可以写成
new ExportExcel(null, ReportBean.class)









3.class对象
String s="hah";
//以 String 的形式返回此 Class 对象所表示的实体即包名
System.out.println(s.getClass().getName());
还可以使用一个类字面值（JLS Section 15.8.2）来获取指定类型（或 void）的 Class 对象。例如： 
System.out.println("The name of class Foo is: "+Foo.class.getName());

输出为：
java.lang.String
3.
动态加载类：动态加载类，在运行时刻才会加载
如使用Class.forName()动态加载类
程序中功能性的类一般会使用动态加载
静态加载类：编译时刻加载类是静态加载类
new 创建对象是静态加载类，在编译时刻就需要加载所有的可能使用到的类。
所以一旦有一个加载有问题，程序就不会正常运行。可以通过动态加载类来解决这个问题



method类：
public Method[] getDeclaredMethods()返回类或接口声明的所有方法，包括public, protected, default (package) 访问和private方法的Method对象，但不包括继承的方法。当然也包括它所实现接口的方法。
public Method[] getMethods()返回某个类的所有public方法，包括其继承类的公用方法，当然也包括它所实现接口的方法。


