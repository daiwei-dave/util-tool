




概念：
1.设计模式更多的是一种对代码的规范，而无什么具体的高深算法
















创建型模式

一。单例模式

在阎宏博士的《JAVA与模式》一书中开头是这样描述单例模式的：在阎宏博士的《JAVA与模式》一书中开头是这样描述单例模式的：

　　作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。

单例模式的结构
　　单例模式的特点：

单例类只能有一个实例。
单例类必须自己创建自己的唯一实例。
单例类必须给所有其他对象提供这一实例。

二。工厂模式

工厂模式简单的说就是将接口的实例封装在工厂类里，而工厂类直接提供一个参数（接口），接口直接调用该参数就可获得其对应的
实体类。大大的提高了团队开发效率，在spring中的IOC和DI（依赖注入）中应用极为广泛

代码：
/**
 * 左偏分发型
 * @author Administrator
 *
 */
public class LeftHair implements HairInterface {

	@Override
	public void draw() {
		// TODO Auto-generated method stub
		System.out.println("-----------------左偏分发型-------------------");
	}

}


/**
	 * 根据类的名称来生产对象
	 * @param className
	 * @return
	 */
	public HairInterface getHairByClass(String className){
		HairInterface hair;
		try {
			hair = (HairInterface) Class.forName(className).newInstance();
			return hair;
		} catch (InstantiationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
		
	}
//测试类
public class Test {
    public static void main(String[] args) {
        HairInterface left=factory.getHairByClass("com.sunny.project.LeftHair");
		left.draw();
    }
}






结构型模式


1。代理模式（spring中的aop部分应用及广）
在阎宏博士的《JAVA与模式》一书中开头是这样描述代理（Proxy）模式的：

　　代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。

代理模式就如将一个对象的某些或全部特性托管给其他的对象，由托管对象向被托管的对象进行操作。

在代理模式中的角色：

　　●　　抽象对象角色：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。

　　●　　目标对象角色：定义了代理对象所代表的目标对象。

　　●　　代理对象角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，
以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。



1.使用代理可以就可以调用被代理对象的一些方法了。还可以做一些附加的操作如打印日志。



参考有：http://www.cnblogs.com/java-my-life/archive/2012/04/23/2466712.html

2。适配器模式（Adapter）


在阎宏博士的《JAVA与模式》一书中开头是这样描述适配器（Adapter）模式的：


适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。


　模式所涉及的角色有：

　　●　　目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。

　　●　　源(Adapee)角色：现在需要适配的接口。

　　●　　适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。




@see http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html


行为型模式

一.责任链模式
在阎宏博士的《JAVA与模式》一书中开头是这样描述责任链（Chain of Responsibility）模式的：

责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。
请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，
这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。


责任链模式涉及到的角色如下所示：

　　●　　抽象处理者(Handler)角色：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。
这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。

　　●　　具体处理者(ConcreteHandler)角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，
因此，如果需要，具体处理者可以访问下家。



纯的与不纯的责任链模式
　　一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又 把责任向下传的情况。

　　在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。

　　纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。有些人认为不纯的责任链根本不是责任链模式，这也许是有道理的。但是在实际的系统里，纯的责任链很难找到。如果坚持责任链不纯便不是责任链模式，那么责任链模式便不会有太大意义了。




二。策略模式

策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，
从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。



这个模式涉及到三个角色：

　　●　　环境(Context)角色：持有一个Strategy的引用。

　　●　　抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。

　　●　　具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。




认识策略模式
　　策略模式的重心

　　策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。

　　算法的平等性

　　策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。

　　所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。

　　运行时策略的唯一性

　　运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。

　　公有的行为

　　经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。



三。模版模式

又叫模板方法模式，在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情晗拢重新定义算法中的某些步骤。
 


四。代维自定义模式：

1.抽象类，泛型模式
优点：可以减少重复冗余的代码，便于维护

