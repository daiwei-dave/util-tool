

1.<load-on-startup>1</load-on-startup>的含义是：

标记容器是否在启动的时候就加载这个servlet。

当值为0或者大于0时，表示容器在应用启动时就加载这个servlet，值越低越先被加载

当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。




2.<display-name>Web应用名称


<!--配置session超时时间，单位分钟 -->
    <session-config>
        <session-timeout>15</session-timeout>
    </session-config>







3.  <!--
tomcat启动时需要进行初始化的参数
@see http://perfy315.iteye.com/blog/2009258
classpath：只会到你的class路径中查找找文件; 
classpath*：不仅包含class路径，还包括jar文件中(class路径)进行查找. 用classpath*:需要遍历所有的classpath，所以加载速度是很慢的，因此，在规划的时候，应该尽可能规划好资源文件所在的路径，尽量避免使用classpath*。
    -->
	<context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>
            classpath:spring-context.xml
        </param-value>
    </context-param>  
	
	<error-page>
		<!--抛出org.apache.shiro.session.InvalidSessionException异常时，跳转到invalidSession.jsp-->
        <exception-type>org.apache.shiro.session.InvalidSessionException</exception-type>
        <location>/invalidSession.jsp</location>
    </error-page>
	
	
4. <!--servlet Filter that allows one to specify a character encoding for requests
过滤器
-->
1）
	<filter>
    <filter-name>encoding</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name><!--用来指定一个具体的字符集，请求与响应都将会设置层utf-8 -->
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <param-name>forceEncoding</param-name><!--true：无论request是否指定了字符集，都是用encoding；false：如果request已指定一个字符集，则不使用encoding-->
        <param-value>false</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>encoding</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>


2）
<!-- Spring Secutiry4.1的过滤器链配置 -->
<filter>
<filter-name>springSecurityFilterChain</filter-name>
<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
<filter-name>springSecurityFilterChain</filter-name>
<url-pattern>/*</url-pattern>
</filter-mapping>


3）
<!-- Shiro Filter -->

    <filter>
        <filter-name>shiroFilter</filter-name>
        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
        <init-param>
            <param-name>targetFilterLifecycle</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
	<!-- 注释掉就可以用postman测试了 -->
    <filter-mapping>
        <filter-name>shiroFilter</filter-name>
        <url-pattern>/*</url-pattern>
		<!-- request请求将会被此过滤器过滤 @http://blog.csdn.net/jethai/article/details/52345135 -->
		<dispatcher>REQUEST</dispatcher>
    </filter-mapping>
	
	
5.监听器

<!-- 防止spring内存溢出监听器 -->
    <listener>
        <listener-class>org.springframework.web.util.IntrospectorCleanupListener</listener-class>
    </listener>	
	
	
6.servlet
<!-- spring mvc servlet -->
    <servlet>
        <description>spring mvc servlet</description>
        <servlet-name>springMvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springMvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
	
	<!-- rop servlet -->
	<servlet>
        <servlet-name>rop</servlet-name>
        <servlet-class>
            com.rop.RopServlet
        </servlet-class>
        <load-on-startup>2</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>rop</servlet-name>
        <url-pattern>/router</url-pattern>
    </servlet-mapping>	
	
	
	
	
	
	