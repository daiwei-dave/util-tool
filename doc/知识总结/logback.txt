

引用官网
1）logback.qos.ch/manual/configuration.html






一。介绍
Logback的目的是作为流行的log4j项目的继承者，拾起log4j离开的地方。

Logback的架构足够通用，以便在不同的情况下应用。目前，logback分为三个模块，logback-core，logback-classic和logback-access。

logback-core模块为其他两个模块打下了基础。
logback-classic模块可以被同化为一个显着改进的log4j版本。此外，logback-classic本地实现了SLF4J API，以便您可以轻松地在logback和其他日志框架（例如log4j或java.util.logging（JUL））之间来回切换。

logback-access模块与Servlet容器（例如Tomcat和Jetty）集成，以提供HTTP访问日志功能。请注意，您可以在logback-core之上轻松构建自己的模块。



二。Reasons to prefer logback over log4j

Logback带来了大量的改进超过log4j，大和小。他们太多，无法详尽列举。然而，这里是一个非穷尽的列表，
从log4j切换到logback的原因。请记住，logback在概念上非常类似于log4j，因为这两个项目都是由同一个开发人员创建的。
如果你已经熟悉log4j，你会很快感觉到在家使用logback。如果你喜欢log4j，你可能会喜欢logback。


1）更快的实现

基于我们之前在log4j上的工作，logback内部已经重写，以在某些关键执行路径上执行大约十倍。不仅logback组件更快，它们具有更小的内存占用。

2）广泛的测试
Logback有一个非常广泛的测试开发了几年和无尽的工作时间的过程。虽然log4j也进行了测试，logback将测试完全不同的级别。在我们看来，这是比log4j更喜欢logback的唯一最重要的原因。你希望你的日志框架是坚如磐石和可靠的，即使在不利的条件下。

3）logback-classic speaks SLF4J natively

由于Loggerlogback-classic中的类本身实现了SLF4J API，因此当使用logback-classic作为底层实现来调用SLF4J记录器时，会产生零开销。
此外，由于logback-classic强烈鼓励使用SLF4J作为其客户端API，如果您需要切换到log4j或jul，
则可以通过将另一个jar文件替换为另一个jar文件来实现。您不需要通过SLF4J API触摸代码记录。这可以大大减少切换日志框架所涉及的工作。


4）自动重新加载配置文件

Logback-classic can automatically reload its configuration file upon modification，扫描过程快速，无争用，并且可以动态扩展到数百万次调用，每秒传播数百个线程

5）从I / O故障中平稳恢复

的logback的FileAppender及其所有子类，包括RollingFileAppender，可以优雅从I / O故障中恢复。因此，如果文件服务器临时失败，您不再需要重新启动您的应用程序，以使日志再次工作。一旦文件服务器恢复，相关的logback appender将透明地并快速地从先前的错误状态恢复。


6）自动删除旧日志存档

7）自动压缩归档日志文件

RollingFileAppender 可以在翻转期间自动压缩归档的日志文件。压缩始终异步发生，因此即使对于大型日志文件，您的应用程序也不会在压缩期间阻塞。

谨慎模式


综上所述

我们列出了一些比log4j更喜欢logback的原因。鉴于logback建立在我们以前的log4j工作，简单地说，logback只是一个更好的log4j。



引用：http://www.cnblogs.com/warking/p/5710303.html

二、logback取代log4j的理由：
　　1、更快的实现：Logback的内核重写了，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升了，初始化内存加载也更小了。
　　2、非常充分的测试：Logback经过了几年，数不清小时的测试。Logback的测试完全不同级别的。
　　3、Logback-classic非常自然实现了SLF4j：Logback-classic实现了SLF4j。在使用SLF4j中，你都感觉不到logback-classic。而且因为logback-classic非常自然地实现了slf4j ， 所 以切换到log4j或者其他，非常容易，只需要提供成另一个jar包就OK，根本不需要去动那些通过SLF4JAPI实现的代码。
　　4、非常充分的文档 官方网站有两百多页的文档。
　　5、自动重新加载配置文件，当配置文件修改了，Logback-classic能自动重新加载配置文件。扫描过程快且安全，它并不需要另外创建一个扫描线程。这个技术充分保证了应用程序能跑得很欢在JEE环境里面。
　　6、Lilith是log事件的观察者，和log4j的chainsaw类似。而lilith还能处理大数量的log数据 。
　　7、谨慎的模式和非常友好的恢复，在谨慎模式下，多个FileAppender实例跑在多个JVM下，能 够安全地写道同一个日志文件。RollingFileAppender会有些限制。Logback的FileAppender和它的子类包括 RollingFileAppender能够非常友好地从I/O异常中恢复。
　　8、配置文件可以处理不同的情况，开发人员经常需要判断不同的Logback配置文件在不同的环境下（开发，测试，生产）。而这些配置文件仅仅只有一些很小的不同，可以通过,和来实现，这样一个配置文件就可以适应多个环境。
　　9、Filters（过滤器）有些时候，需要诊断一个问题，需要打出日志。在log4j，只有降低日志级别，不过这样会打出大量的日志，会影响应用性能。在Logback，你可以继续 保持那个日志级别而除掉某种特殊情况，如alice这个用户登录，她的日志将打在DEBUG级别而其他用户可以继续打在WARN级别。要实现这个功能只需加4行XML配置。可以参考MDCFIlter 。
　　10、SiftingAppender（一个非常多功能的Appender）：它可以用来分割日志文件根据任何一个给定的运行参数。如，SiftingAppender能够区别日志事件跟进用户的Session，然后每个用户会有一个日志文件。
　　11、自动压缩已经打出来的log：RollingFileAppender在产生新文件的时候，会自动压缩已经打出来的日志文件。压缩是个异步过程，所以甚至对于大的日志文件，在压缩过程中应用不会受任何影响。
　　12、堆栈树带有包版本：Logback在打出堆栈树日志时，会带上包的数据。
　　13、自动去除旧的日志文件：通过设置TimeBasedRollingPolicy或者SizeAndTimeBasedFNATP的maxHistory属性，你可以控制已经产生日志文件的最大数量。如果设置maxHistory 12，那那些log文件超过12个月的都会被自动移除。


三。demo

package logback;  
  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
  
public class LogbackDemo {  
    private static Logger log = LoggerFactory.getLogger(LogbackDemo.class);  
    public static void main(String[] args) {  
        log.trace("======trace");  
        log.debug("======debug");  
        log.info("======info");  
        log.warn("======warn");  
        log.error("======error");  
           
        String name = "Aub";  
        String message = "3Q";  
        String[] fruits = { "apple", "banana" };  
          
        // logback提供的可以使用变量的打印方式，结果为"Hello,Aub!"  
        log.info("Hello,{}!", name);  
          
        // 可以有多个参数,结果为“Hello,Aub! 3Q!”  
        log.info("Hello,{}!   {}!", name, message);  
          
        // 可以传入一个数组，结果为"Fruit:  apple,banana"  
        log.info("Fruit:  {},{}", fruits);   
    }  
}  

四、logback的默认配置
如果配置文件 logback-test.xml 和 logback.xml 都不存在，那么 logback 默认地会调用BasicConfigurator ，创建一个最小化配置。最小化配置由一个关联到根 logger 的ConsoleAppender 组成。输出用模式为%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n 的 PatternLayoutEncoder 进行格式化。root logger 默认级别是 DEBUG。
　　1、Logback的配置文件
Logback 配置文件的语法非常灵活。正因为灵活，所以无法用 DTD 或 XML schema 进行定义。尽管如此，可以这样描述配置文件的基本结构：以<configuration>开头，后面有零个或多个<appender>元素，有零个或多个<logger>元素，有最多一个<root>元素。
　　2、Logback默认配置的步骤
　　　　(1). 尝试在 classpath下查找文件logback-test.xml；
　　　　(2). 如果文件不存在，则查找文件logback.xml；
　　　　(3). 如果两个文件都不存在，logback用BasicConfigurator自动对自己进行配置，这会导致记录输出到控制台。
